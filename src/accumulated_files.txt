FILE PATH: ./components/GameControls.jsx
----------------------------
import React from 'react';

const GameControls = ({ onPlayClick, onPassClick, canPlay, canPass, playText = "Play Selected" }) => {
  return (
    <div className="game-controls">
      <button
        className="action-button" // Reuse styles if desired
        onClick={onPlayClick}
        disabled={!canPlay}
      >
        {playText}
      </button>
      <button
        className="fold-button" // Reuse styles if desired, maybe rename class
        onClick={onPassClick}
        disabled={!canPass}
      >
        Pass
      </button>
    </div>
  );
};

export default GameControls;


FILE PATH: ./components/cards/Card.jsx
----------------------------
import React from 'react';
import { renderUnicodeSuitSymbol } from '../../utils/ui'; // Keep this utility

const Card = (props) => {
  const {
    cardData, // Contains suit, cardFace, value, id, animationDelay
    isSelected, // New prop to indicate selection
    onClick, // New prop for handling clicks
    applyFoldedClassname // Keep for potential future use (like showing played cards fading out)
  } = props;

  // Basic validation
  if (!cardData || !cardData.suit || !cardData.cardFace) {
     // Render a placeholder or null if cardData is incomplete
     // This prevents errors if dealing isn't finished or data is bad
     // console.warn("Incomplete card data received:", cardData);
     return <div className="playing-card empty-card"></div>;
  }

  const { suit, cardFace, animationDelay } = cardData;

  // Determine card color
  const color = (suit === 'Diamond' || suit === 'Heart') ? 'red' : 'black';

  // Add 'selected' class if the card is selected
  const selectedClass = isSelected ? ' selected' : '';
  const foldedClass = applyFoldedClassname ? ' folded' : ''; // Keep folded animation possibility

  return (
    <div
      key={cardData.id} // Use the unique ID
      className={`playing-card cardIn${selectedClass}${foldedClass}`}
      style={{ animationDelay: `${applyFoldedClassname ? 0 : animationDelay || 0}ms` }}
      onClick={onClick} // Call the passed onClick handler
    >
      <h6 style={{ color: color }}>
        {`${cardFace} ${renderUnicodeSuitSymbol(suit)}`}
      </h6>
    </div>
  );
};

export default Card;


FILE PATH: ./components/cards/TablePile.jsx
----------------------------
import React from 'react';
import Card from './Card';

const TablePile = ({ cardsOnTable }) => {
  // If there are no cards, return an empty placeholder
  if (!cardsOnTable || cardsOnTable.length === 0) {
    return <div className="table-pile-container empty-pile"></div>;
  }

  // Simple stacking display for now
  return (
    <div className="table-pile-container">
      {cardsOnTable.map((card, index) => (
        <div
          key={`table-${card.id}-${index}`} // Use unique card ID
          className="table-card-wrapper"
          style={{
            position: 'absolute',
            left: `${index * 15}px`, // Adjust overlap amount
            top: `${index * 2}px`,   // Slight vertical offset
            zIndex: index,
          }}
        >
          <Card
            cardData={card}
            isSelected={false} // Cards on table are not selectable
            applyFoldedClassname={false}
          />
        </div>
      ))}
      {/* Add a label */}
      <div style={{ position: 'absolute', top: '-20px', left: '0', color: 'white', fontSize: '12px', width: '100%', textAlign: 'center' }}>
         Current Pile
      </div>
    </div>
  );
};

export default TablePile;


FILE PATH: ./components/cards/HiddenCard.jsx
----------------------------
// ./components/cards/HiddenCard.jsx
// Make sure it accepts cardData and uses animationDelay
import React from 'react';

const HiddenCard = ({ cardData, applyFoldedClassname }) => {
  // Use cardData.id for the key if available, otherwise fallback
  const key = cardData?.id || `${cardData?.suit}-${cardData?.cardFace}-${Math.random()}`;
  const animationDelay = cardData?.animationDelay || 0;

  return (
    <div
      key={key} // Use a unique key
      // Apply base playing-card styles AND robotcard styles
      className={`playing-card robotcard cardIn${applyFoldedClassname ? ' folded' : ''}`}
      style={{ animationDelay: `${applyFoldedClassname ? 0 : animationDelay}ms` }}
    >
      {/* Content is intentionally empty for a hidden card */}
    </div>
  );
};

export default HiddenCard;


FILE PATH: ./components/slider/Handle.jsx
----------------------------
import React from 'react';

function Handle({
  handle: { id, value, percent },
  getHandleProps
}) {
  return (
    <div
      style={{
        left: `${percent}%`,
        position: 'absolute',
        marginLeft: -15,
        marginTop: 25,
        zIndex: 2,
        width: 30,
        height: 30,
        border: 0,
        textAlign: 'center',
        cursor: 'pointer',
        borderRadius: '50%',
        backgroundColor: '#2C4870',
        color: '#aaa',
      }}
      {...getHandleProps(id)}
    >
      <div style={{ display: 'flex', textShadow: '2px 2px 8px rgba(0,0,0,0.95)', justifyContent: 'center', fontFamily: 'Roboto', fontSize: 11, marginTop: 30}} >
        {value}
      </div>
    </div>

  )
}

export default Handle;


FILE PATH: ./components/slider/styles.js
----------------------------
const sliderStyle = {
  position: 'relative',
  width: '100%',
  height: 80,
}
  
const railStyle = {
  position: 'absolute',
  width: '100%',
  height: 10,
  marginTop: 35,
  borderRadius: 5,
  backgroundColor: '#8B9CB6',
}

export { sliderStyle, railStyle }


FILE PATH: ./components/slider/Track.jsx
----------------------------
import React from 'react';

function Track ({ source, target, getTrackProps }) {
  return(
    <div
    style={{
        position: 'absolute',
        height: 10,
        zIndex: 1,
        marginTop: 35,
        backgroundColor: '#546C91',
        borderRadius: 5,
        cursor: 'pointer',
        left: `${source.percent}%`,
        width: `${target.percent - source.percent}%`,
    }}
    {...getTrackProps()}
    />
  )
}
  
export default Track;


FILE PATH: ./components/players/PlayerStatusNotificationBox.jsx
----------------------------
import React from 'react';
import { CSSTransition } from 'react-transition-group';

function PlayerStatusNotificationBox({index, isActive, content, endTransition}) {
    return(
        <CSSTransition 
            in={isActive} 
            timeout={{
                appear: 0,
                enter: 0,
                exit: 1250,
               }}
            classNames="transitionable-actionBox" 
            onEntered={() => {
              setTimeout(() => {
                endTransition(index)
              }, 25)
            }}
        >
            <div className="actionBox">
            {`${content}`}
            </div>
        </CSSTransition>
    )
}

export default PlayerStatusNotificationBox;


FILE PATH: ./components/players/Player.jsx
----------------------------
// ./components/players/Player.jsx
import React from 'react';
import Card from '../cards/Card';
import HiddenCard from '../cards/HiddenCard'; // Import HiddenCard
import PlayerStatusNotificationBox from "./PlayerStatusNotificationBox";

const Player = (props) => {
  const {
    player,
    isCurrentPlayer,
    onCardClick,
    selectedCards,
    playerAnimationSwitchboard,
    endTransition,
    arrayIndex
  } = props;

  if (!player) return null;

  const { name, hand, isHuman, avatarURL } = player;

  const renderPlayerCards = () => {
    if (!hand) return null;

    const numCards = hand.length;
    const maxRotation = 45; // Max angle for the fan (degrees)
    const cardWidth = 25; // Approx width from CSS
    const baseYOffset = -10; // How much the fan is lifted

    return hand.map((card, index) => {
      const isSelected = !isHuman ? false : selectedCards && selectedCards.some(selCard => selCard.id === card.id);

      // Calculate position for fanning effect
      const centerIndex = (numCards - 1) / 2;
      const rotation = numCards > 1 ? (index - centerIndex) * (maxRotation / centerIndex) : 0;
      // Adjust Y offset to create an arc - more offset for outer cards
      const arcFactor = Math.abs(index - centerIndex);
      const yOffset = baseYOffset - (arcFactor * 1.5); // Adjust multiplier for more/less arc
      // Adjust X offset for horizontal spread
      const xOffset = (index - centerIndex) * (cardWidth * 0.8); // Increased multiplier
      
      const cardStyle = {
        position: 'absolute',
        zIndex: index, // Cards in middle overlap outer ones
        transform: `
          translateX(${xOffset}px)
          ${isSelected ? 'translateY(-15px)' : ''}`,
        transition: 'transform 0.2s ease-out', // Smooth selection animation
      };

      if (!isHuman) {
        // Render HiddenCard for non-human players
        return (
          <div key={card.id} style={cardStyle}>
            <HiddenCard
              cardData={card} // Pass card data even if not fully used visually
              applyFoldedClassname={false}
            />
          </div>
        );
      } else {
        // Render regular Card for human player
        return (
          <div key={card.id} style={cardStyle}>
            <Card
              cardData={card}
              isSelected={isSelected}
              onClick={() => onCardClick(card)}
              applyFoldedClassname={false}
            />
          </div>
        );
      }
    });
  };

  const ifAnimating = (playerBoxIndex) => {
    return playerAnimationSwitchboard && playerAnimationSwitchboard[playerBoxIndex]?.isAnimating;
  }

  return (
    <div className={`player-entity--wrapper p${arrayIndex}`}>
      {playerAnimationSwitchboard && endTransition &&
        <PlayerStatusNotificationBox
          index={arrayIndex}
          isActive={ifAnimating(arrayIndex)}
          content={playerAnimationSwitchboard[arrayIndex]?.content || ''}
          endTransition={endTransition}
        />
      }
      {/* Container for the fanned cards */}
      <div className='abscard player-hand-container'> {/* Added class */}
        {renderPlayerCards()}
      </div>
      {/* Player Info */}
      <div className="player-entity--container">
        <div className="player-avatar--container">
          {avatarURL && <img
            className={`player-avatar--image${(isCurrentPlayer ? ' activePlayer' : '')}`}
            src={avatarURL}
            alt="Player Avatar"
          />}
          <h5 className="player-info--name"> {/* Removed inline style, control via CSS */}
            {name}
          </h5>
          {/* Card count is now positioned via CSS */}
          <div className="player-info--card-count">
            Cards: {hand ? hand.length : 0}
          </div>
        </div>
      </div>
    </div>
  );
};

export default Player;


FILE PATH: ./index.js
----------------------------
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));



FILE PATH: ./index.css
----------------------------
body {
  margin: 0;
  padding: 0;
  font-family: sans-serif;
}



FILE PATH: ./App.css
----------------------------
h1, h2, h3, h4, h5, h6 {
  margin: 0;
}
.App {
  text-align: center;
}

.App-logo {
  animation: App-logo-spin infinite 20s linear;
  height: 80px;
}

.App-header {
  background-color: #222;
  height: 65px;
  padding: 20px;
  color: white;
}

.App-title {
  font-size: 1.5em;
}

.App-intro {
  font-size: large;
}

@keyframes App-logo-spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}



FILE PATH: ./logo.svg
----------------------------
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3">
    <g fill="#61DAFB">
        <path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/>
        <circle cx="420.9" cy="296.5" r="45.7"/>
        <path d="M520.5 78.1z"/>
    </g>
</svg>



FILE PATH: ./Poker.css
----------------------------
html,
body, 
#root,
.App {
	width: 100%;
	height: 100%;
}
img {
	width: 100%;
	height: 100%;
}
.centered-flex-row {
	display: flex;
	justify-content: center;
	align-items: center;
	width: auto;
	height: auto;
}

.spinner-container {
	display: flex;
	flex-direction: column;
	align-items: center;

	height: 200px;
	width: 200px;

	animation: App-logo-spin infinite 20s linear;
}

.loading-container {
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100%;
	width: 100%
}

.flex-centered-column {
	display: flex;
	flex-direction: column;
	align-items: center;

	width: auto;
	height: auto;
}

.playing-card.selected {
	border: 2px solid yellow;
	box-shadow: 0 0 10px yellow; /* Add glow effect */
	transform: translateY(-10px); /* Add lift effect here */ /* Adjust px as needed */
  }

.table-pile-container { 
	position: relative; 
	width: 200px; 
	height: 50px; 
}
.game-controls { 
	display: flex;
	 justify-content: center;
	  align-items: center;
	   width: 100%;
	    height: 100%;
}
.player-info--card-count {
    position: absolute;
    bottom: -30px; /* Position it below the name */
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 11px;
    text-shadow: 1px 1px 2px black;
    background-color: rgba(0, 0, 0, 0.6); /* Optional: add background for readability */
    padding: 2px 5px;
    border-radius: 3px;
    white-space: nowrap; /* Prevent wrapping */
}

.playing-card {
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background-color: white;
	font-size: 1em; /* Consider making slightly smaller if needed */
	height: 40px;
	width: 25px;
	/* margin: 0 -2px; */ /* REMOVE NEGATIVE MARGIN */
    margin: 0; /* Reset margin */
	border: 1px solid gray;
	border-radius: 2px; /* Optional: slightly rounded corners */
	box-shadow: 1px 1px 3px rgba(0,0,0,0.3); /* Optional: add shadow */

	opacity: 0;
	animation: fade-in-up 0.5s;
	animation-fill-mode: both;

    /* Prevent text selection */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}


.robotcard {
	background-color: #890808;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='12' viewBox='0 0 20 12'%3E%3Cg fill-rule='evenodd'%3E%3Cg id='charlie-brown' fill='%23ffffff' fill-opacity='0.4'%3E%3Cpath d='M9.8 12L0 2.2V.8l10 10 10-10v1.4L10.2 12h-.4zm-4 0L0 6.2V4.8L7.2 12H5.8zm8.4 0L20 6.2V4.8L12.8 12h1.4zM9.8 0l.2.2.2-.2h-.4zm-4 0L10 4.2 14.2 0h-1.4L10 2.8 7.2 0H5.8z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    height: 40px; /* Match playing card */
	width: 25px;  /* Match playing card */
    border: 1px solid #500000; /* Darker border */
    border-radius: 2px;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
}
.folded {
	animation: fade-in-out 0.5s;
	animation-fill-mode: both;
}

/* Card Animations */

@keyframes fade-in-out {
	0% {
		opacity: 1;
		transform: translateY(0%);
	}
	100% {
		opacity: 0;
		transform: translateY(-100%)
	}
}

@keyframes fade-in-up {
	0% {
		opacity: 0;
		transform: translateY(100%)
	}
	100% {
		opacity: 1;
		transform: translateY(0%);
	}
}

/* Action Status Notification Base Styles & Transitions*/

.actionBox {
	/* background: rgba(0,0,0,0.85); */ 
	color: yellow;
	text-shadow: 2px 2px 10px rgba(0,0,0,1);
	padding: 12px;
	
	position: absolute;
	top: -30px;
	width: 100%;
	left: 50%;
	transform: translateX(-50%);
	z-index: 100;
	display: none;
	justify-content: center;
}

.transitionable-actionBox-enter {
	display: flex;
	opacity: 1;
	transform: translateX(-50%);
}

.transitionable-actionBox-enter-active {
	display: flex;
	opacity: 1;
	transition: opacity 1250ms ease-in-out;
	transform: translateX(-50%);
}
.transitionable-actionBox-enter-done {
	display: flex;
}

.transitionable-actionBox-exit {
	display: flex;
	opacity: 1;
	transform: translateX(-50%);
}

.transitionable-actionBox-exit-active {
	display: flex;
	opacity: 0;
	transform: translateX(-50%) translateY(-55px);
	transition: opacity 1250ms ease-in-out, transform 1250ms linear;
}




/* GAME BOARD */

.poker-app--background {
	position: relative;
	overflow: auto;
	width: 100%;
	height: 100%;
}
 .p0, .p1, .p2, .p3, .p4 {
 	position: absolute;

 	display: flex;
 	align-items: center;
 	flex-direction: column;

	/* 
 	width: 175px;
 	height: 200px;
	
	 border-radius: 200px;
	 */
 }

 .p0 { /* Human - Bottom Center */
	bottom: 0%;
   	left: 50%;
}
.p1 { /* Player 2 - Bottom Left */
	bottom: 10%;
	left: 5%;
}
.p2 { /* Player 3 - Top Left */
	top: 10%;
	left: 5%;
}
.p3 { /* Player 4 - Top Right */
	top: 10%;
	right: 5%;
}
.p4 { /* Player 5 - Bottom Right */
	bottom: 15%;
	right: 5%;
}


 .community-card-container {
 	position: absolute;
 	display: flex;
 	justify-content: center;

 	top: calc(39.5% - 60px);
 	left: calc(50% - 100px);
 	
 	display: flex;

 	width: 200px;
 	height: 60px;

 }

 .showdown-container--community-cards {
	display: flex;
	height: 52px;
	margin-bottom: 1rem;
 }

 .cardbabmock {
 	width: 85px;
 	margin-left: 5px;
 	height: 100px;
 	background-color: black;
 }

 .game-action-bar {
 	position: absolute;

 	display: flex;
 	align-items: center;
 	justify-content: space-around;

 	left: 0;
 	right: 0;
 	top: 0;
 	height: 50px;
 	background-color: rgba(0,0,0,0.85);
 	color: white;
 }


 .abscard {
	position: absolute;
   height: 50px; /* Increased slightly for arc, adjust as needed */
   pointer-events: none; /* Container shouldn't block clicks */
}

/* Add this new rule to allow clicks on the cards themselves */
.abscard > div { /* Targets the wrapper divs generated in Player.jsx */
    pointer-events: auto;
}

 .shrinkwrap {
 	transform: scale(0.3);
 }

 .action-buttons {
 	display: flex;
 	align-items: center;
 	justify-content: space-around;
 	width: auto;
 	height: 100%;
 }

 .slider-boi {
 	display: flex;
 	align-items: center;
 	justify-content: flex-end;
 	width: 55%;
 	height: 100%;
 }

 .action-button {
 	height: 45px;
 	width: 125px;
 	margin: 0 12px;
 	border-radius: 500px;
 	background-color: rgba(242, 242, 242, 0.80);
 	font-size: 28px;
 	color: white;
 	background-color: #2adb2a;
 	border: 3px solid white;
 	outline: none;
 	transition: background-color 0.4s ease-out, color 0.4s ease-out;
 }
 .action-button:hover {
 	cursor: pointer;
 	background-color: #ffc935;
	color: #f56132;
 }
 .fold-button {
 	height: 45px;
 	width: 125px;
 	margin: 0 12px;
 	background-color: rgba(255, 80, 80, 0.8);
 	font-size: 28px;
 	color: white;
 	outline: none;
 	z-index: 100;
 	border-radius: 500px;
 	border: 3px solid white;
 	transition: background-color 0.4s ease-out, color 0.4s ease-out;
 }
 .fold-button:hover {
 	background-color: rgb(255, 0, 0);
 	cursor: pointer;
 }

 .player-hand-container {
    position: relative; /* Crucial for positioning the absolute cards within */
 }


 .player-info-box {
 	display: flex;
 	flex-direction: column;
 	align-items: center;
 	color: white;
 	background-color: rgba(0,0,0,0.35);
 	font-size: 0.87em;
 	z-index: 99;

 	padding: 12px;
 	margin-top: 12px;
 }

.player-info-box h5 {
	margin: 4px 0;
}

 .slider-handles > div > div {
	 color: white !important;
	 font-size: 24px !important;
 }

 .showdown-row {
 	display: flex;
 	flex-direction: column;
 	align-items: center;
 	align-items: center;

 	margin-bottom: 15px;
 }

.pot-container {
	position: absolute;
	top: 40%;
	left: calc(50% - 22.5px);
	color: white;
}

.player-entity--container {
	display: flex;
	height: auto;
	width: auto;
}
.player-entity--wrapper {
	position: absolute;
	/* background-color: rgba(0,0,0,0.35); */
	border-top-left-radius: 200px;
	border-bottom-left-radius: 200px;
}
.player-avatar--container {
	position: relative; /* Ensure this is relative for absolute positioning of children */
	height: 100px;
	width: 100px;
	border-radius: 100px;
	padding: 6px 6px 6px 6px;
    margin-bottom: 25px; /* Add some space below the avatar area for the count */
}

.player-avatar--image {
	border-radius: 500px;
	border: 1px solid whitesmoke;
	background-color: rgba(176, 14, 14, 0.22);
	transition: border 0.1s ease-out;
}

.activePlayer {
	border: 2px solid #00ff25;
}

.player-info--wrapper {
	width: 100px;
	color: white;
}

.player-info--stash--container,
.player-info--bet--container {
	display: flex;
	align-items: center;
	justify-content: center;
	color: white;
	margin-top: 10px;
	text-shadow: 2px 2px 18px rgba(0,0,0,0.95);
}


.player-info--stash--image,
.player-info--bet--image {
	height: 25px;
	width: 25px;
}

.poker-table--wrapper {
	position: relative;
	width: 100%;
	height: 100%;
	background-image: radial-gradient(#8B0000 60%, #6A0000 82%);
}

.poker-table--container {
	position: absolute;
}

.showdown-container--wrapper {
	display: flex;
   	flex-direction: column;
	align-items: center;
	position: absolute;
	overflow: auto;
	left: 0;
	right: 0;
	top: 0;
	background-color: rgba(0,0,0,0.85);
	color: white;
	height: auto;
	min-height: 100%;
	width: 100%;
	z-index: 100;
}

.showdown-container--title {
	font-size: 28px;
	margin: 0 6px;
}

.showdown-container--community-card-label {
	margin: 12px 0;
}

.showdown-container--messages {
	text-align: left;
}

.showdown-player--entity {
	display: flex;
	align-items: center;
	margin-bottom: 8px;
	height: 112px;
}


.showdownPlayer--data,
.showdownPlayer--privateCards  {
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}
.showdown-player--besthand--container {
	margin-left: 12px;
}

.showdown-player--entity .player-avatar--container {
	margin-right: 12px;
}

.showdown-player--entity .player-info--name {
	border: 1px solid white;
}

.showdown-player--besthand--cards {
	display: flex;
	justify-content: center;
	align-items: center;
	width: auto;
	height: auto;
}

.player-entity--container {
	display: flex;
}

.showdown--handrank {
	width: 115px;
	text-align: center;
	color: #FDBA0A;
	font-size: 13px;
}

.message--earnings {
	color: #FDBA0A;
}

.message--rank {
	color: #714794;
}
.showdownPlayer--cards {
	display: flex;
}

.showdownPlayer--earnings {
	text-align: center;
}

.showdownPlayer--earnings.positive,
.message--player {
	color: #4EB04E;
}

.showdownPlayer--earnings.negative {
	color: #97241B;
}

.poker-table--table-image {
	width: 100%;
	height: 100%;
}

.showdown--nextRound--button {
	background-color: #6C0C02;
	border: 1px solid white;
	color: salmon;
	padding: 6px;
	line-height: 1;
}
.showdown--nextRound--button:hover {
	cursor: pointer;
}

@media (min-width: 1080px) {
	.poker-table--container {
		left: 50%;
		top: 50%;
		transform: translate(-50%, -50%);
		width: 1080px;
		height: 590px;
	}
	
}


@media (max-width: 1079px) {
	.poker-table--container {
		position: absolute;
		top: 50%;
		transform: translateY(-50%);
		width: 100%;
		height: auto;
	}
	.player-info--bet--container {
		position: absolute;
		top: -20px;
		left: 50%;
		transform: translateX(-50%);
		width: 100%;
		color: whitesmoke;
		border-radius: 100px;
		background-color: rgba(0,0,0,10);
		border: 1px solid white;
	}
	.pot-container {
		top: 55px;
		right: 20%;
		left: unset;
	}
}

@media (max-width: 736px) {
	.player-avatar--container {
		height: 75px;
		width: 75px;
	}	
	.player-info--name {
		width: 100px;
	}
}

@media (max-width: 552px) {
	.poker-table--container {
		transform: rotate(90deg);
	}
}



FILE PATH: ./utils/players.js
----------------------------
import uuid from 'uuid/v1';
import { dealMissingCommunityCards, generateDeckOfCards, shuffle } from './cards.js';

const axios = require('axios')
// TODO Generate UUID to simulate User ID and really get a perf match on binding to players when determining winnings
const generateTable = async () => {
	const users = [{
		id: uuid(),
		name: 'Player 1',
		avatarURL: '/assets/boy.svg',
		cards: [],
		bet: 0,
		betReconciled: false,
		folded: false,
		canRaise: true,
		stackInvestment: 0,
		robot: false
	}];

	const response = await axios.get(`https://randomuser.me/api/?results=4&nat=us,gb,fr`);
	response.data.results
		.map(user => {
			return ({
				id: uuid(),
				name: `${user.name.first.charAt(0).toUpperCase()}${user.name.first.slice(1)} ${user.name.last.charAt(0).toUpperCase()}${user.name.last.slice(1)}`,
				avatarURL: user.picture.large,
				cards: [],
				bet: 0,
				betReconciled: false,
				folded: false,
				robot: true,
				canRaise: true,
				stackInvestment: 0,
			})
		})
		.forEach(user => users.push(user))

	return users
}

const handleOverflowIndex = (currentIndex, incrementBy, arrayLength, direction) => {
	switch (direction) {
		case('up'): {
			return (
				(currentIndex + incrementBy) % arrayLength
			)
		}
		case('down'): {
			return (
				((currentIndex - incrementBy) % arrayLength) + arrayLength 
			)
		}
		default: throw Error("Attempted to overfow index on unfamiliar direction");
	}
}



// This function can lead to errors if player all ins at a certain position
// final AI will freeze
// seems to happen when only 2 players left and someone has all-in

const determineNextActivePlayer = (state) => {
	state.activePlayerIndex = handleOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');
	const activePlayer = state.players[state.activePlayerIndex];

	if (activePlayer.folded) {
		console.log("Current player index is folded, going to next active player.")
		return determineNextActivePlayer(state);
	}

	if (
		!activePlayer.folded &&
		activePlayer.betReconciled
	) {
		return(showDown(reconcilePot(dealMissingCommunityCards(state))));
	}

	// IF a player is all in, he will be reconciled?
	if (activePlayer.betReconciled) {
		console.log("Player is reconciled with pot, round betting cycle complete, proceed to next round.")
		return handlePhaseShift(state);
	}

	return state
}

const beginNextRound = (state) => {
	state.communityCards = [];
	state.sidePots = [];
	state.playerHierarchy = [];
	state.showDownMessages = [];
	state.deck = shuffle(generateDeckOfCards())
	state.highBet = 20;
	state.betInputValue = 20;
	state.minBet = 20; // can export out to initialState
	// Unmount all cards so react can re-trigger animations
	const { players } = state;
	const clearPlayerCards = players.map(player => ({...player, cards: player.cards.map(card => {})}))
	state.players = clearPlayerCards;
	return passDealerChip(state)
}

// NEED INITIAL PLAYER STATE
// INITIAL TABLE STATE
export { generateTable, handleOverflowIndex, determineNextActivePlayer, beginNextRound, checkWin }


FILE PATH: ./utils/cards.js
----------------------------
import { handleOverflowIndex } from './players.js';

const totalNumCards = 52;
const suits = ['Heart', 'Spade', 'Club', 'Diamond'];
const cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const VALUE_MAP = {
	2:1,
	3:2,
	4:3,
	5:4,
	6:5,
	7:6,
	8:7,
	9:8,
	10:9,
	J:10,
	Q:11,
	K:12,
	A:13,
};

const randomizePosition = (min, max) => {
	min = Math.ceil(min);
  	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1)) + min;
}


const generateDeckOfCards = () => {
	const deck = [];

	for (let suit of suits) {
		for (let card of cards) {
			deck.push({
				cardFace: card,
				suit: suit,
				value: VALUE_MAP[card]
			})
		}
	}
		return deck
}

const shuffle = (deck) => {
	let shuffledDeck = new Array(totalNumCards);
	let filledSlots = [];
	for (let i = 0; i < totalNumCards; i++) {
		if (i === 51) {
			// Fill last undefined slot when only 1 card left to shuffle
			const lastSlot = shuffledDeck.findIndex((el) => typeof el == 'undefined');
				shuffledDeck[lastSlot] = deck[i];
				filledSlots.push(lastSlot);
		} else {
			let shuffleToPosition = randomizePosition(0, totalNumCards - 1);
				while (filledSlots.includes(shuffleToPosition)) {
					shuffleToPosition = randomizePosition(0, totalNumCards - 1);
				}
						shuffledDeck[shuffleToPosition] = deck[i];
						filledSlots.push(shuffleToPosition);
		}
	}
	return shuffledDeck
}

const popCards = (deck, numToPop) => {
	// Note: While this is a Shallow Copy, (It copies the references to the children) - note that we are mutating it by 
	// Actually modifying the array, NOT the children. This is why the length of mutableCopy changes, but that of deck 
	// Does not.
	const mutableDeckCopy = [...deck];
	let chosenCards;
	if (numToPop === 1) {
		chosenCards = mutableDeckCopy.pop();
	} else {
		chosenCards = [];
		for(let i = 0; i < numToPop; i++) {
			chosenCards.push(mutableDeckCopy.pop());
		}
	}
		return { mutableDeckCopy, chosenCards }
}

const popShowdownCards = (deck, numToPop) => {
	// When dealMissingCommunityCards was calling popCards() with the condition numToPop === 1
	// It was returning a raw object instead of an array, and calling a for...of loop, causing the program to crash
	// Until we can refactor this code and all of its calling functions 
	// (change the code for dealFlop/River/Turn to use a consistent .concat function instead of .push())
	// We'll just duplicat this code here and utilize it in dealMissingCommunityCards
	const mutableDeckCopy = [...deck];
	let chosenCards;
	if (numToPop === 1) {
		chosenCards = [mutableDeckCopy.pop()];
	} else {
		chosenCards = [];
		for(let i = 0; i < numToPop; i++) {
			chosenCards.push(mutableDeckCopy.pop());
		}
	}
		return { mutableDeckCopy, chosenCards }
}

const dealPrivateCards = (state) => {
		// Clear any "clear cards" flag if it exists
		state.clearCards = false;
		let animationDelay = 0;
		
		// Continue dealing until the deck is empty
		while (state.deck.length > 0) {
		  // Pop a single card from the deck
		  const { mutableDeckCopy, chosenCards } = popCards(state.deck, 1);
		  
		  // Add animation delay (similar to your dealPrivateCards function)
		  chosenCards.animationDelay = animationDelay;
		  animationDelay = animationDelay + 250;
		  
		  // Add the card to the current active player's hand
		  state.players[state.activePlayerIndex].cards.push(chosenCards);
		  
		  // Update the deck
		  state.deck = [...mutableDeckCopy];
		  
		  // Move to the next player
		  state.activePlayerIndex = handleOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');
		}
		
		// Move to the next phase after all cards are dealt
		state.phase = 'allCardsDealt';
		
		return state;
};


const buildValueSet = (hand) => {
	return Array.from(new Set(hand.map(cardInfo => cardInfo.value)))
}

const dealMissingCommunityCards = (state) => {
	const cardsToPop = 5 - state.communityCards.length
	if (cardsToPop >= 1) {
		let animationDelay = 0;
		const { mutableDeckCopy, chosenCards } = popShowdownCards(state.deck, cardsToPop);
			
			for (let card of chosenCards) {
				card.animationDelay = animationDelay;
				animationDelay = animationDelay + 250;
				state.communityCards.push(card);
			}

		state.deck = mutableDeckCopy;
	}
	state.phase = 'showdown'
	return state
}

// Add these functions to your existing utils/cards.js file


const throwCardsToTable = (cardsToThrow, playerId, gameState) => {
	// Create a copy of the game state to modify
	const newGameState = { ...gameState };
	
	// Add the thrown cards to the table
	newGameState.cardsOnTable = [
	  ...cardsToThrow.map(card => ({
		...card,
		playedBy: playerId,
		animationDelay: Math.random() * 200 // Randomize animation for natural look
	  }))
	];
	
	// Update the player's hand by removing the thrown cards
	const playerIndex = newGameState.players.findIndex(player => player.name === playerId);
	if (playerIndex >= 0) {
	  // Filter out the cards that were thrown
	  newGameState.players[playerIndex].cards = newGameState.players[playerIndex].cards.filter(
		playerCard => !cardsToThrow.some(
		  thrownCard => thrownCard.suit === playerCard.suit && thrownCard.cardFace === playerCard.cardFace
		)
	  );
	}
	
	return newGameState;
  };
  

const clearTableCards = (gameState) => {
	return {
	  ...gameState,
	  cardsOnTable: []
	};
  };

export { generateDeckOfCards, shuffle, popCards, dealPrivateCards, dealMissingCommunityCards, buildValueSet, throwCardsToTable, clearTableCards }


FILE PATH: ./utils/ui.js
----------------------------
const renderUnicodeSuitSymbol = (suit) => {
	switch(suit) {
		case('Heart'): return '\u2665';
		case('Diamond'): return '\u2666';
		case('Spade'): return '\u2660';
		case('Club'): return '\u2663';
		default: throw Error('Unfamiliar String Recieved in Suit Unicode Generation');
	}
}


export { 
	renderUnicodeSuitSymbol, 
}




FILE PATH: ./utils/scumLogic.js
----------------------------
// utils/scumLogic.js

const SUITS = ['Heart', 'Spade', 'Club', 'Diamond'];
const FACES = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];

// Assign numerical values for comparison (3 is lowest, 2 is highest)
const VALUE_MAP = FACES.reduce((map, face, index) => {
  map[face] = index + 1; // 3=1, 4=2, ..., A=12, 2=13
  return map;
}, {});

/**
 * Generates a standard 52-card deck for Scum.
 */
export const generateDeck = () => {
  const deck = [];
  for (const suit of SUITS) {
    for (const face of FACES) {
      deck.push({
        cardFace: face,
        suit: suit,
        value: VALUE_MAP[face],
        id: `${face}-${suit}` // Unique ID for React keys
      });
    }
  }
  return deck;
};

/**
 * Shuffles a deck of cards using the Fisher-Yates algorithm.
 */
export const shuffleDeck = (deck) => {
  let shuffledDeck = [...deck]; // Create a copy
  for (let i = shuffledDeck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledDeck[i], shuffledDeck[j]] = [shuffledDeck[j], shuffledDeck[i]]; // Swap elements
  }
  return shuffledDeck;
};

/**
 * Deals cards from the deck to players.
 * Returns the updated players array and the remaining deck.
 */
export const dealCards = (deck, players) => {
  let currentDeck = [...deck];
  const numPlayers = players.length;
  const updatedPlayers = players.map(p => ({ ...p, hand: [] })); // Clear hands first
  let playerIndex = 0;

  while (currentDeck.length > 0) {
    const card = currentDeck.pop();
    // Add animation delay if needed (optional)
    card.animationDelay = playerIndex * 50 + updatedPlayers[playerIndex % numPlayers].hand.length * 20;
    updatedPlayers[playerIndex % numPlayers].hand.push(card);
    playerIndex++;
  }

  // Sort each player's hand for better display
  updatedPlayers.forEach(player => {
    player.hand.sort((a, b) => a.value - b.value);
  });

  return { updatedPlayers, remainingDeck: currentDeck };
};

/**
 * Gets the Scum value of a card.
 */
export const getCardValue = (card) => {
  return card.value;
};

/**
 * Checks if a proposed play is valid according to Scum rules.
 *
 * @param {Array} selectedCards - The cards the player wants to play.
 * @param {Array} cardsOnTable - The cards currently in the pile/trick.
 * @returns {Boolean|String} - True if valid, or a string message if invalid.
 */
export const isValidPlay = (selectedCards, cardsOnTable) => {
  if (!selectedCards || selectedCards.length === 0) {
    return "No cards selected.";
  }

  // Check if all selected cards have the same face value
  const firstCardValue = selectedCards[0].value;
  if (!selectedCards.every(card => card.value === firstCardValue)) {
    return "Selected cards must have the same rank.";
  }

  const numSelected = selectedCards.length;

  // --- Playing onto an empty table ---
  if (!cardsOnTable || cardsOnTable.length === 0) {
    // Any single, double, triple, or quad is valid to start
    if (numSelected >= 1 && numSelected <= 4) {
      return true; // Valid lead play
    } else {
      return "Invalid number of cards to lead.";
    }
  }

  // --- Playing onto existing cards ---
  const numOnTable = cardsOnTable.length;
  const tableValue = cardsOnTable[0].value;

  // Must play the same number of cards
  if (numSelected !== numOnTable) {
    return `Must play ${numOnTable} card(s).`;
  }

  // Must play a higher rank
  if (firstCardValue <= tableValue) {
    return "Must play a higher rank.";
  }

  // If all checks pass
  return true;
};

/**
 * Finds the index of the next player who hasn't finished.
 */
export const findNextPlayerIndex = (currentIndex, players) => {
    let nextIndex = (currentIndex + 1) % players.length;
    let attempts = 0;
    // Keep looping until we find a player with cards, or we've checked everyone
    while (players[nextIndex].hand.length === 0 && attempts < players.length) {
        nextIndex = (nextIndex + 1) % players.length;
        attempts++;
    }
    // If all players are finished (attempts === players.length), return -1 or handle game over
    if (attempts === players.length) return -1; // Or handle appropriately
    return nextIndex;
};


/**
 * Finds all valid plays a player can make given their hand and the cards on table.
 *
 * @param {Array} hand - The player's hand.
 * @param {Array} cardsOnTable - The cards currently on the table.
 * @returns {Array} - An array of valid plays (each play is an array of cards).
 */
export const findValidPlays = (hand, cardsOnTable) => {
    const validPlays = [];
    if (!hand || hand.length === 0) {
      return validPlays; // No cards, no plays
    }
  
    // Group hand by card value
    const cardsByValue = hand.reduce((groups, card) => {
      const value = card.value;
      if (!groups[value]) {
        groups[value] = [];
      }
      groups[value].push(card);
      return groups;
    }, {});
  
    // Check potential plays (singles, doubles, triples, quads)
    for (const value in cardsByValue) {
      const group = cardsByValue[value];
      // Check singles
      if (isValidPlay([group[0]], cardsOnTable) === true) {
        validPlays.push([group[0]]);
      }
      // Check doubles
      if (group.length >= 2 && isValidPlay(group.slice(0, 2), cardsOnTable) === true) {
        validPlays.push(group.slice(0, 2));
      }
      // Check triples
      if (group.length >= 3 && isValidPlay(group.slice(0, 3), cardsOnTable) === true) {
        validPlays.push(group.slice(0, 3));
      }
      // Check quads
      if (group.length >= 4 && isValidPlay(group.slice(0, 4), cardsOnTable) === true) {
        validPlays.push(group.slice(0, 4));
      }
    }
  
    return validPlays;
  };


FILE PATH: ./acc.sh
----------------------------
#!/bin/bash

# Check if a directory is provided
if [ $# -eq 0 ]; then
    echo "Usage: $0 <directory_path> [output_file]"
    exit 1
fi

# Set the input directory
INPUT_DIR="$1"

# Set the output file (default if not provided)
OUTPUT_FILE="${2:-accumulated_files.txt}"

# Check if the input directory exists
if [ ! -d "$INPUT_DIR" ]; then
    echo "Error: Directory $INPUT_DIR does not exist."
    exit 1
fi

# Clear the output file if it already exists
> "$OUTPUT_FILE"

# Find and process all files in the directory (including subdirectories)
find "$INPUT_DIR" -type f | while read -r file; do
    # Add a separator and the file path
    echo "FILE PATH: $file" >> "$OUTPUT_FILE"
    echo "----------------------------" >> "$OUTPUT_FILE"
    
    # Add the contents of the file
    cat "$file" >> "$OUTPUT_FILE"
    
    # Add an extra newline to separate files
    echo -e "\n\n" >> "$OUTPUT_FILE"
done

echo "All files have been accumulated in $OUTPUT_FILE"



FILE PATH: ./App.test.js
----------------------------
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<App />, div);
  ReactDOM.unmountComponentAtNode(div);
});



FILE PATH: ./accumulated_files.txt
----------------------------



FILE PATH: ./Spinner.js
----------------------------
import React from 'react';

const Spinner = props => {
	return(
		<div className="loading-container">
			<div className='spinner-container' >
				<img src={'/assets/chip.svg'} alt="Loading..."/>
			</div>
		</div>
	)
}

export default Spinner


FILE PATH: ./WinScreen.js
----------------------------
import React from 'react';

const WinScreen = () => <div> You Win! </div>

export default WinScreen;


FILE PATH: ./App.jsx
----------------------------
import React, { Component } from 'react';
import './App.css';
import './Poker.css'; // Keep for layout and card styles

import Spinner from './Spinner'; // Keep
// import WinScreen from './WinScreen'; // Keep or adapt

import Player from "./components/players/Player";
import TablePile from "./components/cards/TablePile"; // Use the new TablePile
import GameControls from "./components/GameControls"; // Use the new GameControls

// Import Scum logic functions
import {
  generateDeck,
  shuffleDeck,
  dealCards,
  isValidPlay,
  findNextPlayerIndex,
  findValidPlays, // *** Make sure this is imported ***
} from './utils/scumLogic.js';

// Keep UI utils if needed (like renderUnicodeSuitSymbol used by Card)
// import { renderUnicodeSuitSymbol } from './utils/ui';

import { cloneDeep } from 'lodash'; // Useful for deep copying state

const NUM_PLAYERS = 5;
const AI_DELAY = 1; // Use the constant (seconds)

class App extends Component {
  state = {
    loading: true,
    gamePhase: 'loading', // 'loading', 'dealing', 'playing', 'roundOver', 'gameOver'
    players: [], // { id, name, hand, isHuman, finishedRank }
    deck: [],
    cardsOnTable: [], // Cards in the current trick/pile
    currentPlayerIndex: 0,
    lastPlayerToPlay: null, // Index of the player who last successfully played cards
    trickLeadPlayerIndex: 0, // Who started the current trick
    passCounter: 0, // Consecutive passes
    roundWinners: [], // Order players finished the round
    gameMessage: 'Starting Game...',
    selectedCards: [], // Cards selected by the human player { id, suit, cardFace, value }
    playerAnimationSwitchboard: this.initializeAnimationSwitchboard(NUM_PLAYERS),
  };

  // Holds the timeout ID for the AI turn
  aiTurnTimeout = null; // Initialize here

  initializeAnimationSwitchboard(numPlayers) {
    const switchboard = {};
    for (let i = 0; i < numPlayers; i++) {
      switchboard[i] = { isAnimating: false, content: null };
    }
    return switchboard;
  }

  componentDidMount() {
    this.startGame();
  }

  // *** REVISED componentDidUpdate ***
  componentDidUpdate(prevProps, prevState) {
    const { gamePhase, players, currentPlayerIndex } = this.state;
    const currentPlayer = players[currentPlayerIndex];

    // --- AI Turn Trigger Logic ---
    // Check if it's an AI's turn NOW and it wasn't their turn before (or game just started/resumed)
    if (
      gamePhase === 'playing' &&
      currentPlayer && !currentPlayer.isHuman && // It's an AI's turn
      (prevState.currentPlayerIndex !== currentPlayerIndex || // The turn just changed to this player
       (prevState.gamePhase !== 'playing' && gamePhase === 'playing')) // Or the game just resumed on this player's turn
    ) {
      // Clear any *previous* timeout just in case (e.g., if updates happened very fast)
      if (this.aiTurnTimeout) {
        clearTimeout(this.aiTurnTimeout);
      }
      console.log(`[AI Trigger] Setting AI timeout for Player ${currentPlayerIndex} (${currentPlayer.name})`); // Debug log
      this.aiTurnTimeout = setTimeout(this.handleAiTurn, AI_DELAY * 5000);
    }

    // --- Cleanup Logic ---
    // If the game is NO LONGER playing, clear any pending AI timeout.
    if (prevState.gamePhase === 'playing' && gamePhase !== 'playing') {
      if (this.aiTurnTimeout) {
        clearTimeout(this.aiTurnTimeout);
        this.aiTurnTimeout = null;
        console.log("[AI Cleanup] Game phase changed, clearing AI timeout."); // Debug
      }
    }

    // Optional: If the player changed *away* from the AI before its timeout fired
    // This is less common but can happen with rapid state changes.
    const prevPlayer = prevState.players[prevState.currentPlayerIndex];
    if (prevState.gamePhase === 'playing' && gamePhase === 'playing' && // Game is still playing
        prevState.currentPlayerIndex !== currentPlayerIndex && // Player changed
        prevPlayer && !prevPlayer.isHuman && // It *was* an AI's turn
        this.aiTurnTimeout) // And there was a timeout pending
     {
         // Check if the timeout was for the player whose turn it just was
         // (This check is implicitly handled by clearing any timeout above when setting a new one,
         // but explicit clearing here adds safety if the trigger logic were different)
         // console.log(`[AI Cleanup] Player changed away from AI ${prevState.currentPlayerIndex} before timeout fired. Clearing.`);
         // clearTimeout(this.aiTurnTimeout);
         // this.aiTurnTimeout = null;
         // This part might be redundant with the trigger logic clearing previous timeouts,
         // but keep it in mind if you encounter edge cases.
     }
  }

  // *** ADDED componentWillUnmount ***
  componentWillUnmount() {
    // Clear any pending timeout when the component is removed
    if (this.aiTurnTimeout) {
      clearTimeout(this.aiTurnTimeout);
      this.aiTurnTimeout = null;
      console.log("[AI Cleanup] Component unmounting, clearing AI timeout."); // Debug
    }
  }


  handleAiTurn = () => {
    const { players, currentPlayerIndex, cardsOnTable, gamePhase } = this.state;
    const aiPlayer = players[currentPlayerIndex];

    console.log(`[AI Turn] Handling turn for Player ${currentPlayerIndex} (${aiPlayer?.name})`); // Debug log

    // Reset timeout handle now that it has fired
    this.aiTurnTimeout = null;

    if (!aiPlayer || aiPlayer.isHuman || gamePhase !== 'playing') {
      console.warn("[AI Turn] AI turn triggered incorrectly or game state changed.", {
          hasPlayer: !!aiPlayer,
          isHuman: aiPlayer?.isHuman,
          gamePhase: gamePhase
      });
      return; // Safety check
    }

    // 1. Find all valid plays for the AI
    // *** Ensure findValidPlays is correctly imported and implemented ***
    const possiblePlays = findValidPlays(aiPlayer.hand, cardsOnTable);
    console.log(`[AI Turn] Player ${currentPlayerIndex} Hand:`, aiPlayer.hand);
    console.log(`[AI Turn] Cards on Table:`, cardsOnTable);
    console.log(`[AI Turn] Possible Plays:`, possiblePlays); // Debug log

    // 2. Decide action: Play or Pass
    if (possiblePlays.length > 0) {
      // Simple random AI: choose a random valid play
      // TODO: Implement better AI strategy later
      const randomIndex = Math.floor(Math.random() * possiblePlays.length);
      const selectedPlay = possiblePlays[randomIndex];

      console.log(`[AI Turn] Player ${currentPlayerIndex} chose to PLAY:`, selectedPlay); // Debug log
      // Simulate the play action (similar to handlePlayCards but without UI selection)
      this.executePlay(selectedPlay);

    } else {
      // No valid plays, AI must pass
      console.log(`[AI Turn] Player ${currentPlayerIndex} has no valid plays, PASSING.`); // Debug log
      this.handlePass(); // Use the existing pass handler
    }
  };

  // Refactored play logic to be callable by both human and AI
  executePlay = (cardsToPlay) => {
    const { players, currentPlayerIndex, cardsOnTable } = this.state;
    const currentPlayer = players[currentPlayerIndex];
    const playerName = currentPlayer?.name || `Player ${currentPlayerIndex}`;

    console.log(`[Execute Play] ${playerName} attempts to play:`, cardsToPlay);

    // Basic validation (should already be valid if coming from AI findValidPlays)
    const validationResult = isValidPlay(cardsToPlay, cardsOnTable);
     if (validationResult !== true) {
       console.error(`[Execute Play] AI ${playerName} attempted invalid play!`, {
           cardsToPlay,
           cardsOnTable,
           reason: validationResult
       });
       // As a fallback, make the AI pass if something went wrong
       this.handlePass();
       return;
     }

    // --- Play is Valid ---
    this.pushAnimationState(currentPlayerIndex, `Plays ${cardsToPlay.length} card(s)`);

    // 1. Remove cards from player's hand
    const newHand = currentPlayer.hand.filter(card =>
      !cardsToPlay.some(selCard => selCard.id === card.id)
    );
    const updatedPlayers = cloneDeep(players);
    updatedPlayers[currentPlayerIndex].hand = newHand;

    // 2. Update cards on table
    const newCardsOnTable = [...cardsToPlay]; // Replace the pile

    // 3. Check if player finished
    let newRoundWinners = [...this.state.roundWinners];
    if (newHand.length === 0 && !this.state.roundWinners.includes(currentPlayer.id)) {
        newRoundWinners.push(currentPlayer.id);
        const finishedRank = newRoundWinners.length;
        updatedPlayers[currentPlayerIndex].finishedRank = finishedRank;
        this.pushAnimationState(currentPlayerIndex, `Finished ${finishedRank}!`);
        console.log(`[Execute Play] ${playerName} finished in rank ${finishedRank}`);
    }

    // 4. Check for round end
    const playersStillPlaying = updatedPlayers.filter(p => p.hand.length > 0 && p.finishedRank === null);
    console.log(`[Execute Play] Players still playing: ${playersStillPlaying.length}`);

    if (playersStillPlaying.length <= 1) {
        // If exactly one player is left, assign them the last rank
        if (playersStillPlaying.length === 1) {
            const lastPlayer = playersStillPlaying[0];
            if (!newRoundWinners.includes(lastPlayer.id)) {
                 newRoundWinners.push(lastPlayer.id);
                 const lastRank = newRoundWinners.length;
                 const lastPlayerIndexInAll = updatedPlayers.findIndex(p => p.id === lastPlayer.id);
                 if (lastPlayerIndexInAll !== -1) {
                    updatedPlayers[lastPlayerIndexInAll].finishedRank = lastRank;
                    console.log(`[Execute Play] ${lastPlayer.name} finished last (rank ${lastRank})`);
                 }
            }
        }

        // Ensure all players have a rank if round ends abruptly
        updatedPlayers.forEach((p, index) => {
            if (p.hand.length > 0 && p.finishedRank === null) {
                 if (!newRoundWinners.includes(p.id)) {
                     newRoundWinners.push(p.id);
                     p.finishedRank = newRoundWinners.length;
                     console.warn(`[Execute Play] Force assigning rank ${p.finishedRank} to ${p.name} at round end.`);
                 }
            }
        });


        const winner = updatedPlayers.find(p => p.finishedRank === 1);
        console.log("[Execute Play] Round Over!");
        this.setState({
            players: updatedPlayers,
            roundWinners: newRoundWinners,
            gamePhase: 'roundOver',
            gameMessage: `Round Over! ${winner?.name || 'Winner'} is President!`,
            cardsOnTable: newCardsOnTable, // Show the last play briefly
            selectedCards: [], // Clear human selection
            currentPlayerIndex: -1, // No current player
            lastPlayerToPlay: currentPlayerIndex, // Keep track of who played last
        }, () => {
             // Start next round after a delay
             setTimeout(this.startNextRound, 5000); // Increased delay to see results
        });
        return; // Stop further processing for this turn
    }

    // 5. Determine next player (ensure skipping finished players)
    const nextPlayerIndex = findNextPlayerIndex(currentPlayerIndex, updatedPlayers);
    const nextPlayerName = updatedPlayers[nextPlayerIndex]?.name || `Player ${nextPlayerIndex}`;
    console.log(`[Execute Play] Next player index: ${nextPlayerIndex} (${nextPlayerName})`);


    // 6. Update state for next turn
    this.setState({
      players: updatedPlayers,
      cardsOnTable: newCardsOnTable,
      lastPlayerToPlay: currentPlayerIndex,
      currentPlayerIndex: nextPlayerIndex,
      passCounter: 0, // Reset pass counter on a successful play
      gameMessage: `${nextPlayerName}'s turn.`,
      selectedCards: [], // Clear human selection
      roundWinners: newRoundWinners,
    });
  }

  // Modify handlePlayCards to use executePlay
  handlePlayCards = () => {
    const { selectedCards, players, currentPlayerIndex, cardsOnTable } = this.state;
    const currentPlayer = players[currentPlayerIndex];

    if (!currentPlayer || !currentPlayer.isHuman) {
        console.warn("handlePlayCards called when not human player's turn.");
        return;
    }

    // Validation is still useful for human player feedback
    const validationResult = isValidPlay(selectedCards, cardsOnTable);
    if (validationResult !== true) {
      this.setState({ gameMessage: validationResult });
      return;
    }
    this.executePlay(selectedCards); // Call the shared logic
  };

  startGame = () => {
    console.log("--- Starting Game ---");
    this.setState({ loading: true, gameMessage: 'Setting up the table...' });

    // Clear any lingering timeouts from previous games/rounds
    if (this.aiTurnTimeout) {
        clearTimeout(this.aiTurnTimeout);
        this.aiTurnTimeout = null;
    }

    // 1. Create Players
    const players = [];
    for (let i = 0; i < NUM_PLAYERS; i++) {
      players.push({
        id: `player-${i}`,
        name: i === 0 ? 'You' : `AI Player ${i + 1}`, // Player 0 is human
        hand: [],
        isHuman: i === 0,
        finishedRank: null, // Reset rank
        avatarURL: i === 0 ? '/assets/boy.svg' : `https://i.pravatar.cc/100?img=${i}` // Example avatars
      });
    }

    // 2. Create and Shuffle Deck
    const deck = shuffleDeck(generateDeck());

    // 3. Deal Cards
    const { updatedPlayers, remainingDeck } = dealCards(deck, players);

    // Sort human player's hand initially
    if (updatedPlayers[0]) {
        updatedPlayers[0].hand.sort((a, b) => a.value - b.value);
    }

    // Determine starting player (e.g., player with 3 of Diamonds, or just player 0)
    // For simplicity, let's start with player 0
    const startingPlayerIndex = 0; // TODO: Implement actual starting rule (e.g., 3 of Diamonds)
    const startingPlayerName = updatedPlayers[startingPlayerIndex]?.name || `Player ${startingPlayerIndex}`;

    console.log("Dealing complete. Players:", updatedPlayers);

    this.setState({
      loading: false,
      gamePhase: 'playing',
      players: updatedPlayers,
      deck: remainingDeck, // Should be empty after dealing
      cardsOnTable: [],
      currentPlayerIndex: startingPlayerIndex,
      lastPlayerToPlay: null,
      trickLeadPlayerIndex: startingPlayerIndex,
      passCounter: 0,
      roundWinners: [],
      gameMessage: `${startingPlayerName}'s turn to lead.`,
      selectedCards: [],
      playerAnimationSwitchboard: this.initializeAnimationSwitchboard(NUM_PLAYERS), // Reset animations
    }, () => {
        // This callback ensures state is set before potentially triggering AI
        // Needed if player 0 is AI
        const currentPlayer = this.state.players[this.state.currentPlayerIndex];
        if (this.state.gamePhase === 'playing' && currentPlayer && !currentPlayer.isHuman) {
             console.log("[startGame Callback] First player is AI, triggering timeout.");
             if (this.aiTurnTimeout) clearTimeout(this.aiTurnTimeout); // Clear just in case
             this.aiTurnTimeout = setTimeout(this.handleAiTurn, AI_DELAY * 5000);
        }
    });
  };

  // --- Player Action Handlers ---

  handleCardClick = (card) => {
    // Only allow clicking if it's the human player's turn
    const { players, currentPlayerIndex, gamePhase } = this.state;
    if (gamePhase !== 'playing' || !players[currentPlayerIndex]?.isHuman) {
        return;
    }

    const { selectedCards } = this.state;
    const alreadySelected = selectedCards.some(c => c.id === card.id);

    let newSelectedCards;
    if (alreadySelected) {
      // Deselect card
      newSelectedCards = selectedCards.filter(c => c.id !== card.id);
    } else {
      // Select card
      newSelectedCards = [...selectedCards, card];
    }

    // Sort selected cards by value for consistency
    newSelectedCards.sort((a, b) => a.value - b.value);

    this.setState({ selectedCards: newSelectedCards });
  };

  // handlePlayCards is above (modified to call executePlay)

  handlePass = () => {
    const { players, currentPlayerIndex, passCounter, lastPlayerToPlay, trickLeadPlayerIndex, gamePhase } = this.state;

    // Prevent passing if not playing phase
    if (gamePhase !== 'playing') return;

    const currentPlayer = players[currentPlayerIndex];
    const playerName = currentPlayer?.name || `Player ${currentPlayerIndex}`;
    console.log(`[Handle Pass] ${playerName} passes.`);

    this.pushAnimationState(currentPlayerIndex, 'Passes'); // Optional animation message

    const newPassCounter = passCounter + 1;

    // Count players who haven't finished yet
    const numActivePlayers = players.filter(p => p.finishedRank === null).length;

    // Check if the trick ends
    // Trick ends if:
    // 1. Everyone still in the round (who hasn't finished) except the last person to play has passed.
    // 2. The pass counter reaches (number of active players - 1)
    // 3. There *was* a last player to play (i.e., not the very start of a trick where everyone passes)
    if (lastPlayerToPlay !== null && newPassCounter >= numActivePlayers - 1) {
      // Trick ends, clear the table, last player to play leads next
      const nextLeadPlayerIndex = lastPlayerToPlay;
      const nextLeadPlayerName = players[nextLeadPlayerIndex]?.name || `Player ${nextLeadPlayerIndex}`;
      console.log(`[Handle Pass] Trick ends. ${nextLeadPlayerName} leads next.`);
      this.setState({
        cardsOnTable: [], // Clear the pile
        passCounter: 0,
        currentPlayerIndex: nextLeadPlayerIndex,
        trickLeadPlayerIndex: nextLeadPlayerIndex, // This player starts the new trick
        lastPlayerToPlay: null, // Reset for the new trick
        gameMessage: `${nextLeadPlayerName} cleared the pile and leads next.`,
        selectedCards: [],
      });
    } else {
      // Trick continues, move to next player (skipping finished players)
      const nextPlayerIndex = findNextPlayerIndex(currentPlayerIndex, players);
      const nextPlayerName = players[nextPlayerIndex]?.name || `Player ${nextPlayerIndex}`;
      console.log(`[Handle Pass] Trick continues. Next player: ${nextPlayerIndex} (${nextPlayerName})`);
      this.setState({
        passCounter: newPassCounter,
        currentPlayerIndex: nextPlayerIndex,
        gameMessage: `${nextPlayerName}'s turn.`,
        selectedCards: [], // Clear selection just in case
      });
    }
  };

  startNextRound = () => {
      // Basic reset for now - doesn't handle roles yet
      console.log("--- Starting Next Round ---");
      // TODO: Implement role assignment (President, Scum etc.) and card trading
      // TODO: Determine starting player based on previous round's Scum
      this.startGame(); // Just restart the game for simplicity for now
  };


  // --- Animation Helpers (Optional) ---
  pushAnimationState = (index, content) => {
    if (!this.state.playerAnimationSwitchboard.hasOwnProperty(index)) return; // Safety check
    const newAnimationSwitchboard = {
        ...this.state.playerAnimationSwitchboard,
        [index]: { isAnimating: true, content }
    };
    this.setState({ playerAnimationSwitchboard: newAnimationSwitchboard });
  };

  popAnimationState = (index) => {
    if (!this.state.playerAnimationSwitchboard.hasOwnProperty(index)) return; // Safety check
    // Keep content for display even after animation ends
    const persistContent = this.state.playerAnimationSwitchboard[index]?.content;
    const newAnimationSwitchboard = {
        ...this.state.playerAnimationSwitchboard,
        [index]: { isAnimating: false, content: persistContent }
    };
    this.setState({ playerAnimationSwitchboard: newAnimationSwitchboard });
  };


  // --- Render Methods ---

  renderPlayers = () => {
    const { players, currentPlayerIndex, selectedCards, playerAnimationSwitchboard, gamePhase } = this.state;
    if (!players || players.length === 0) return null;

    // Simple rendering without rotation for now
    return players.map((player, index) => (
      <Player
        key={player.id}
        arrayIndex={index} // For positioning using p0, p1, etc.
        player={player}
        isCurrentPlayer={index === currentPlayerIndex && gamePhase === 'playing'} // Only highlight if playing
        onCardClick={this.handleCardClick}
        selectedCards={player.isHuman ? selectedCards : []} // Only pass selection to human
        // Optional animation props
        playerAnimationSwitchboard={playerAnimationSwitchboard}
        endTransition={this.popAnimationState}
      />
    ));
  };

  renderGameControls = () => {
    const { players, currentPlayerIndex, gamePhase, selectedCards, cardsOnTable } = this.state;
    if (gamePhase !== 'playing' || !players.length) return null;

    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || !currentPlayer.isHuman) return null; // Only show controls for human player

    // Determine if the play button should be enabled
    const playValidity = isValidPlay(selectedCards, cardsOnTable);
    const canPlay = playValidity === true;
    // Player can always pass unless they are leading a new trick (cardsOnTable is empty)
    const canPass = cardsOnTable.length > 0;

    return (
      <GameControls
        onPlayClick={this.handlePlayCards}
        onPassClick={this.handlePass}
        canPlay={canPlay}
        canPass={canPass}
        playText={selectedCards.length > 0 ? `Play ${selectedCards.length} Card(s)` : "Play"}
      />
    );
  };

  render() {
    const { loading, gamePhase, cardsOnTable, gameMessage, players, roundWinners } = this.state;

    if (loading) {
      return <Spinner />;
    }

    // Basic round over screen
    if (gamePhase === 'roundOver') {
        // Sort players by rank for display
        const rankedPlayers = [...players].sort((a, b) => (a.finishedRank || 99) - (b.finishedRank || 99));
        return (
            <div className="App">
                <div className='poker-table--wrapper'> {/* Reuse wrapper */}
                    <div className="showdown-container--wrapper" style={{ justifyContent: 'center', alignItems: 'center', textAlign: 'center', color: 'white', backgroundColor: 'rgba(0,0,0,0.8)', padding: '20px', borderRadius: '10px' }}> {/* Reuse styles */}
                        <h1>Round Over!</h1>
                        <p>{gameMessage}</p>
                        {/* Display final player rankings */}
                        <h3>Results:</h3>
                        <ol style={{ listStylePosition: 'inside', paddingLeft: 0 }}>
                            {rankedPlayers
                                .map(p => <li key={p.id}>{p.name} - Rank {p.finishedRank || 'Unknown'}</li>)
                            }
                        </ol>
                        <p>Starting next round soon...</p>
                        {/* Optional: Button to proceed manually */}
                        {/* <button onClick={this.startNextRound}>Start Next Round</button> */}
                    </div>
                </div>
            </div>
        );
    }


    return (
      <div className="App">
        {/* Reuse the poker table background/layout */}
        <div className='poker-table--wrapper'>
          <div className="poker-table--container">
            {/* You might want a simpler background than the SVG table */}
            {/* <img className="poker-table--table-image" src={"./assets/table-nobg-svg-01.svg"} alt="Poker Table" /> */}

            {/* Render Players */}
            {this.renderPlayers()}

            {/* Render Cards on Table (Pile) */}
            <div className='community-card-container' style={{ top: 'calc(50% - 35px)', height: '70px', display: 'flex', justifyContent: 'center', alignItems: 'center', pointerEvents: 'none' }}> {/* Repositioned & Sized */}
              <TablePile cardsOnTable={cardsOnTable} />
            </div>

            {/* Optional: Display Game Message */}
            <div className='game-message-container' style={{ position: 'absolute', top: '20px', left: '50%', transform: 'translateX(-50%)', color: 'white', backgroundColor: 'rgba(0,0,0,0.7)', padding: '5px 10px', borderRadius: '5px', zIndex: 50, textAlign: 'center', minWidth: '200px' }}>
              {gameMessage}
            </div>

          </div>

          {/* Render Action Buttons for Human Player */}
          <div className='game-action-bar' > {/* Reuse action bar style */}
             {this.renderGameControls()}
             {/* Remove Slider */}
          </div>
        </div>
      </div>
    );
  }
}

export default App;


